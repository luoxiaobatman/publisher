---
created: 2023-09-21
number headings: first-level 2, start-at 1, max 6, 1.1-
title: 预研
author: 罗潇
cssclass: wideTable
first-level: 1
pdf-filename: 预研
platform: true
category: 预研
---

### 用分布式id生成递增来做为数据库主键

在pg里面使用递增的id来作为主键

> [!success] 优点
> 1. **性能**：B-tree经常被用来为主键建立索引，按序插入的值可能会比插入随机值更快，并且引起的页面碎片化更少。
> 2. **范围查询**：当`id`是递增的，执行基于范围的查询很便捷。例如，要获取某个记录之后创建的记录，只需按`id > that_record_id`过滤即可。
> 3. **分区的可扩展性**：如果需要对表进行分区（将数据分布在多个小表中），递增的主键可以使基于范围的分区策略更为简单。
> 4. **含有历史信息**：递增的`id`可以大致说明记录创建的顺序。

> [!warning] 缺点
> - 它们可能会暴露关于记录创建的量或速率的信息，在某些应用中可能是一个关注点（例如，通过查看用户ID猜测有多少用户已经注册）。
> - 在分布式系统中，跨多个数据库实例生成唯一的递增ID可能会很复杂。

#### 进一步分析性能

##### B-tree

B-tree（平衡树）索引是一种数据结构，允许高效地进行插入、删除和搜索操作。当在某列上创建索引时，除非指定了另一种索引类型，否则PostgreSQL将为该索引创建一个B-tree结构。B-tree索引的关键特性是：

- 数据以分层且排序的方式存储。
- 树的每个级别都有一个预定义范围内的特定数量的子节点。

我们进一步分析:
当执行**插入**操作时：当添加具有递增主键的新行时，新值通常会添加到B-tree的最右侧叶节点，性能极高。相比之下，如果插入随机或乱序值，数据库可能需要频繁地重新平衡B-tree的部分，这更加消耗资源。
当执行**搜索**操作时：B-tree索引允许对搜索操作进行对数时间复杂度。递增的ID使范围查询变得高效。例如，如果想找到所有ID在1000到2000之间的行，B-tree可以快速定位并扫描这个连续范围。

##### 碎片化

碎片化是指数据存储空间使用效率低下的情况，减少了容量或性能。在B-tree索引和PostgreSQL的上下文中：

**页面碎片化**：在向索引列中插入随机值时，数据库可能会得到只部分填充的页面 (1) 。随着时间的推移，随着值的插入和删除，可能导致页面内部的散布空闲空间。严格递增的值在很大程度上缓解了这个问题，因为每个新值只是扩展当前页面，直到它满了，然后会分配一个新页面。
{ .annotate }
1. Page, 操作系统内存术语最小管理单元, 一般大小是4K

**逻辑碎片化**：随着时间的推移，随着随机插入和删除，索引数据的逻辑顺序可能与磁盘上的物理顺序不同。这可能导致顺序扫描变慢，因为系统可能需要跳转磁盘的不同部分。对于递增的ID，特别是如果删除很少发生时，索引条目的逻辑顺序通常与其物理顺序很好地对齐。
**维护开销**：PostgreSQL有一个`VACUUM`过程，有助于从已删除的行中回收空间并减少碎片化。随着随机插入和删除，可能需要更频繁地运行VACUUM。对于递增的ID和大多数追加型的工作负载，可能不需要频繁地执行vacuum操作。




| Java HelloWorld                      | Python HelloWorld                    |
| ------------------------------------ | ------------------------------------ |
| ```java  
class HelloWorld {  
    public static void main(String[] args) {    
        System.out.printf("HelloWorld")
    } 
}
``` | ```python
if __name__ == '__main__':  
    print("HelloWorld")
``` | 
