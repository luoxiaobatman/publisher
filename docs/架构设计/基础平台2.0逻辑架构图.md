---
created: 2023-09-22
number headings: first-level 1, start-at 1, max 6, 1.1.
title: 逻辑架构图
author: 罗潇
cssclass: wideTable
first-level: 1
pdf-filename: 基础平台2.0逻辑架构图
platform: true
category: 架构设计
---

![[../assets/img/Pasted image 20230925182609.png|Pasted image 20230925182609]]

**整体逻辑架构分为视图层、业务层、中间层和数据层。**

* 基础功能是通过依赖注入到服务中提供能力，无需独立运行。

* 缓存中心和消息中心可以是高性能独立中间件，也可以是低消耗易部署的嵌入式服务。

* 业务层服务只保留资产，用户，系统，网关，其他都通过基础能力注入到服务中，不再提供单独服务。

* 数据层共有资产库，用户库，系统库，可以独立部署不同数据库实例，也可以部署相同数据库实例，甚至部署到同一个数据库。

# 子系统介绍

基础平台服务包括，API网关、用户服务、资源服务、系统服务、调度服务。

## API服务网关

API网关服务是服务请求入口，为后端服务提供路由、身份认证、操作鉴权、白名单、负载均衡、限流等功能。网关基于业界广泛使用的Spring Cloud Gateway，采用非阻塞的Reactor框架实现的响应式编程模型，具有高性能、高吞吐量和低延迟的优势。

网关服务重要功能包括路由加载，身份认证，操作鉴权，会话管理，详细描述如下：

**路由加载：**后端服务通过基础功能提供服务注册能力直接向网关发送注册信息，然后网关将注册信息转换为路由信息并加载到路由表。路由信息是定时上报，如果固定时间内服务未上报路由信息，网关将判断服务为不可用，从路由表中删除该服务。

**身份认证：**网关判断到请求未登录，将请求重定向到用户登录页面。网关在响应登录请求网时将通过用户服务的Rest接口加载用户信息和权限信息，并验证用户名和密码是否匹配。如果认证出现性能问题，可以将用户信息缓存，避免频繁访问用户服务接口。缓存过期和用户信息修改将通知网关清楚缓存。

**操作鉴权：**网关根据缓存用户权限信息，判断当前请求有权限操作，有权限就路由到对应服务，没有权限返回403**。**

**会话管理：**网关存储每个登录用户的Session信息，转发时需生成JWT格式Token粘连到Request Header。网关支持水平扩容来均衡负载，这时需要进行会话共享，会话存储由内存切换为Redis。

**单网关逻辑图：**

![[../assets/img/Pasted image 20230925182634.png|Pasted image 20230925182634]]

单网关部署时，网关作为注册中心，服务将注册到网关，用户会话信息通过内存存储。

**多网关逻辑图：**

![[../assets/img/Pasted image 20230925182647.png|Pasted image 20230925182647]]

多网关部署时，网关不再作为注册中心，而是由Redis替代。服务将注册信息到Redis，各网关也从Redis获取路由信息，并且将用户会话存储到Redis。

 **认证和鉴权：**

身份认证和操作鉴权统一由网关负责,用户服务负责提供身份和权限信息。针对浏览器、外部API，API网关对业务请求统一进行认证和鉴权，只有携带合法Token的请求会被转发给相应的服务，由相应的服务提供响应。

![[../assets/img/Pasted image 20230925182656.png|Pasted image 20230925182656]]

## 系统管理

系统管理主要实系统配置管理、系统监控、系统升级、License管理、短信网关、网络配置、时间配置等。系统管理功能存在大量与操作系统交互，例如：修改IP，获取时间等，为减轻适配工作量，要求涉及操作系统命令操作统一使用ITR（系统平台）。系统服务将通过Java封装一套API与底层系统平台交互，C接口调用采用JNA，事件接收（TCP通信）采用Netty。

**系统平台介绍**

系统平台是面向天榕所有产品用于向下适配多计算机体系结构和多操作系统的基础公共组件，旨在为产品提供一致的基础运行时环境、编译环境、中间件服务、进程监管服务、计划任务服务、初始化接口和系统管理接口——产品主要关心与 "系统平台" 的适配，而较少关心与具体的硬件平台和操作系统适配，从而降低产品适配不同硬件平台和操作系统的开发成本。

**参见：**[**https://venusgroup.feishu.cn/docx/doxcnvRfuGEfcNFMtLhsdWEk2Sb**](https://venusgroup.feishu.cn/docx/doxcnvRfuGEfcNFMtLhsdWEk2Sb)

**ITR相关功能介绍**

* **License管理：**License由授权工具统一签发，基础平台负责License管理，例如：上传，存储，展示，验证，License的解析由ITR负责。

* **系统配置：**包括网口管理，时间管理，DNS管理，路由管理等，这些功能都和操作密切相关，统一操作ITR完成，不再直接运行操作系统命令。

* **主备管理：**基础平台负责主备管理操作，例如：主备配置，状态展示，主备事件监听等，ITR负责具体主备操作。

* **升级管理：**基础平台负责升级管理操作，例如：升级包上传，升级状态展示，升级事件监听等，ITR负责具体升级包验签，解包，执行等。

**系统服务逻辑图：**

![[../assets/img/Pasted image 20230925182717.png|Pasted image 20230925182717]]

系统服务内置ITR API Caller与ITR Event Listener功能模块，统一与ITR交互。两模块都采用原生Java实现，易扩展，好维护，避免跨语言实现导致维护成本。系统服务其他功能模块不直接与ITR交互，调用ITR API都通过ITR API Caller，ITR事件会通过TR Event Listener广播成Spring Event。

系统服务作为独立工程开发，部署时可选择独立部署或嵌入式部署。嵌入式部署将随宿主服务一起启动，这种部署方式资源消耗低，运维简单。

**嵌入式部署：**

![[../assets/img/Pasted image 20230925182728.png|Pasted image 20230925182728]]

## 用户管理

用户管理包括包括用户、组织机构、用户组、用户自定义属性、用户口令策略、角色、权限等管理功能。用户服务作为独立工程开发，部署时可选择独立部署或嵌入式部署。嵌入式部署将随宿主服务一起启动，这种部署方式资源消耗低，运维简单。

**嵌入式部署：**

![[../assets/img/Pasted image 20230925182737.png|Pasted image 20230925182737]]

**独立部署：**

![[../assets/img/Pasted image 20230925182747.png|Pasted image 20230925182747]]

## 资产管理

资产管理包括资源管理、资源组管理、帐号管理等功能。资产服务作为独立工程开发，部署时可选择独立部署或嵌入式部署。嵌入式部署将随宿主服务一起启动，这种部署方式资源消耗低，运维简单。

**嵌入式部署：**

![[../assets/img/Pasted image 20230925182757.png|Pasted image 20230925182757]]

**独立部署：**

![[../assets/img/Pasted image 20230925182804.png|Pasted image 20230925182804]]

## 消息中心

消息中心是功能解耦，异步处理，削峰填谷的重要技术手段。基础平台1.0采用kafka做为消息中间件，其性能和稳定性都很好满足平台需求，但是kafka+zookeeper组合也加大资源消耗和运维难度。为了降低资源要求，简化运维难度，平台2.0再保留Kafka基础上，设计嵌入式ActiveMQ作为另一种消息中间件选择，它资源消耗低，配置简单，跟随宿主服务一起启动，消息存储使用Postgresql。

**嵌入式MQ逻辑图：**

![[../assets/img/Pasted image 20230925182827.png|Pasted image 20230925182827]]

* ActiveMQ是JMS标准实现，相对Kafka该消息标准功能更强，实现也更复杂，所以嵌入式消息中心性能相较Kafka较低，不适合单位时间大量消息的生产和消费，针对这种场景需要使用kafka这种分布式消息中间件。

* 为灵活切换消息中间件，实现配置化切换，基础平台会封装一套消息注解和API，使用平台API开发功能可以通过配置动态切换嵌入式或分布式MQ。

**独立MQ逻辑图：**

![[../assets/img/Pasted image 20230925182839.png|Pasted image 20230925182839]]

* Kafka作为独立消息中间件，性能更好，更稳定，但是部署更复杂，运维更困难。

## 缓存

缓存是一种介于数据永久存储介质与数据应用之间的数据临时存储介质，使用缓存可以有效的减少数据库的读取次数，降低磁盘IO，提高系统性能。基础平台1.0采用Redis做为缓存中间件，其性能和丰富数据结构都很好满足需求。为了降低资源要求，简化运维难度，平台2.0再保留Redis基础上，设计内存缓存，它资源消耗低，配置简单，跟随宿主服务一起启动。

![[../assets/img/Pasted image 20230925182849.png|Pasted image 20230925182849]]

**优点：**

* 本地缓存配置简单，不用运维。由于无需走Socket通信，读取和写入性能很高。

**缺点：**

* 无分布式概念，每个服务独立管理缓存，服务需单独占用内存来存储数据，服务内存消耗大。

* 不能持久化缓存，服务重启重新从数据库加载缓存。

**针对以上缺点，考虑引入****EhCache作为本地缓存**。EhCache 是一个纯Java的进程内缓存框架，支持磁盘缓存、集群缓存。集群缓存通信使用RMI或网络广播，但是集群缓存配置麻烦，应用不方便，这只是备用选项，分布式缓存优先考虑Redis。

![[../assets/img/Pasted image 20230925182900.png|Pasted image 20230925182900]]

## 内置服务部署

基础平台内置服务都是独立工程开发，针对产品部署要求，服务可以合并部署，也可以独立部署。比如在盒子环境，服务边界比较大，以减少jvm的个数和性能开销；在高性能环境，服务边界比较小，服务独占资源以应付高并发场景。

跨模块的API调用必须支持伸缩性，合并部署走JVM内部调用，独立部署走OpenFeign分布式调用。Controller必须直接指定接口，并且接口上指定OpenFeign注解。

**跨服务跨模块调用**

![[../assets/img/Pasted image 20230925182916.png|Pasted image 20230925182916]]

以上，部署成两个独立的微服务，被调用方的Controller层实例，是没有在调用方微服务中的，调用方调用接口抽象层，在抽象层中实现调用方式的注入，此情形下，通道抽象实现将调用FeignClient实现服务的内部远程调用。

**同服务跨模块**

![[../assets/img/Pasted image 20230925182923.png|Pasted image 20230925182923]]

调用方和被调用方在同一JVM中，被调用方Controller服务在jvm中存在实例，此时模块间调用应当走本地调用。
